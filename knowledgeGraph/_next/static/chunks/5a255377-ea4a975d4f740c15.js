"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[120],{6344:(e,t,i)=>{i.d(t,{Ay:()=>H});var r=i(662);let n=function(){let e=arguments[0];for(let t=1,i=arguments.length;t<i;t++)if(arguments[t])for(let i in arguments[t])e[i]=arguments[t][i];return e};function o(e,t,i,r){let n=e._nodes.get(t),o=null;return n?o="mixed"===r?n.out&&n.out[i]||n.undirected&&n.undirected[i]:"directed"===r?n.out&&n.out[i]:n.undirected&&n.undirected[i]:o}function d(e){return"object"==typeof e&&null!==e}function s(e){let t;for(t in e)return!1;return!0}function a(e,t,i){Object.defineProperty(e,t,{enumerable:!1,configurable:!1,writable:!0,value:i})}function h(e,t,i){let r={enumerable:!0,configurable:!0};"function"==typeof i?r.get=i:(r.value=i,r.writable=!1),Object.defineProperty(e,t,r)}function u(e){return!!d(e)&&(!e.attributes||!!Array.isArray(e.attributes))}function c(){let e=arguments,t=null,i=-1;return{[Symbol.iterator](){return this},next(){let r=null;for(;;){if(null===t){if(++i>=e.length)return{done:!0};t=e[i][Symbol.iterator]()}if((r=t.next()).done){t=null;continue}break}return r}}}function p(){return{[Symbol.iterator](){return this},next:()=>({done:!0})}}"function"==typeof Object.assign&&(n=Object.assign);class l extends Error{constructor(e){super(),this.name="GraphError",this.message=e}}class g extends l{constructor(e){super(e),this.name="InvalidArgumentsGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,g.prototype.constructor)}}class f extends l{constructor(e){super(e),this.name="NotFoundGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,f.prototype.constructor)}}class y extends l{constructor(e){super(e),this.name="UsageGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,y.prototype.constructor)}}function w(e,t){this.key=e,this.attributes=t,this.clear()}function b(e,t){this.key=e,this.attributes=t,this.clear()}function m(e,t){this.key=e,this.attributes=t,this.clear()}function $(e,t,i,r,n){this.key=t,this.attributes=n,this.undirected=e,this.source=i,this.target=r}function k(e,t,i,r,n,o,d){let s,a,h,u;if(r=""+r,0===i){if(!(s=e._nodes.get(r)))throw new f(`Graph.${t}: could not find the "${r}" node in the graph.`);h=n,u=o}else if(3===i){if(n=""+n,!(a=e._edges.get(n)))throw new f(`Graph.${t}: could not find the "${n}" edge in the graph.`);let i=a.source.key,c=a.target.key;if(r===i)s=a.target;else if(r===c)s=a.source;else throw new f(`Graph.${t}: the "${r}" node is not attached to the "${n}" edge (${i}, ${c}).`);h=o,u=d}else{if(!(a=e._edges.get(r)))throw new f(`Graph.${t}: could not find the "${r}" edge in the graph.`);s=1===i?a.source:a.target,h=n,u=o}return[s,h,u]}w.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={}},b.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={}},m.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={}},$.prototype.attach=function(){let e="out",t="in";this.undirected&&(e=t="undirected");let i=this.source.key,r=this.target.key;this.source[e][r]=this,this.undirected&&i===r||(this.target[t][i]=this)},$.prototype.attachMulti=function(){let e="out",t="in",i=this.source.key,r=this.target.key;this.undirected&&(e=t="undirected");let n=this.source[e],o=n[r];if(void 0===o){n[r]=this,this.undirected&&i===r||(this.target[t][i]=this);return}o.previous=this,this.next=o,n[r]=this,this.target[t][i]=this},$.prototype.detach=function(){let e=this.source.key,t=this.target.key,i="out",r="in";this.undirected&&(i=r="undirected"),delete this.source[i][t],delete this.target[r][e]},$.prototype.detachMulti=function(){let e=this.source.key,t=this.target.key,i="out",r="in";this.undirected&&(i=r="undirected"),void 0===this.previous?void 0===this.next?(delete this.source[i][t],delete this.target[r][e]):(this.next.previous=void 0,this.source[i][t]=this.next,this.target[r][e]=this.next):(this.previous.next=this.next,void 0!==this.next&&(this.next.previous=this.previous))};let G=[{name:e=>`get${e}Attribute`,attacher:function(e,t,i){e.prototype[t]=function(e,r,n){let[o,d]=k(this,t,i,e,r,n);return o.attributes[d]}}},{name:e=>`get${e}Attributes`,attacher:function(e,t,i){e.prototype[t]=function(e,r){let[n]=k(this,t,i,e,r);return n.attributes}}},{name:e=>`has${e}Attribute`,attacher:function(e,t,i){e.prototype[t]=function(e,r,n){let[o,d]=k(this,t,i,e,r,n);return o.attributes.hasOwnProperty(d)}}},{name:e=>`set${e}Attribute`,attacher:function(e,t,i){e.prototype[t]=function(e,r,n,o){let[d,s,a]=k(this,t,i,e,r,n,o);return d.attributes[s]=a,this.emit("nodeAttributesUpdated",{key:d.key,type:"set",attributes:d.attributes,name:s}),this}}},{name:e=>`update${e}Attribute`,attacher:function(e,t,i){e.prototype[t]=function(e,r,n,o){let[d,s,a]=k(this,t,i,e,r,n,o);if("function"!=typeof a)throw new g(`Graph.${t}: updater should be a function.`);let h=d.attributes,u=a(h[s]);return h[s]=u,this.emit("nodeAttributesUpdated",{key:d.key,type:"set",attributes:d.attributes,name:s}),this}}},{name:e=>`remove${e}Attribute`,attacher:function(e,t,i){e.prototype[t]=function(e,r,n){let[o,d]=k(this,t,i,e,r,n);return delete o.attributes[d],this.emit("nodeAttributesUpdated",{key:o.key,type:"remove",attributes:o.attributes,name:d}),this}}},{name:e=>`replace${e}Attributes`,attacher:function(e,t,i){e.prototype[t]=function(e,r,n){let[o,s]=k(this,t,i,e,r,n);if(!d(s))throw new g(`Graph.${t}: provided attributes are not a plain object.`);return o.attributes=s,this.emit("nodeAttributesUpdated",{key:o.key,type:"replace",attributes:o.attributes}),this}}},{name:e=>`merge${e}Attributes`,attacher:function(e,t,i){e.prototype[t]=function(e,r,o){let[s,a]=k(this,t,i,e,r,o);if(!d(a))throw new g(`Graph.${t}: provided attributes are not a plain object.`);return n(s.attributes,a),this.emit("nodeAttributesUpdated",{key:s.key,type:"merge",attributes:s.attributes,data:a}),this}}},{name:e=>`update${e}Attributes`,attacher:function(e,t,i){e.prototype[t]=function(e,r,n){let[o,d]=k(this,t,i,e,r,n);if("function"!=typeof d)throw new g(`Graph.${t}: provided updater is not a function.`);return o.attributes=d(o.attributes),this.emit("nodeAttributesUpdated",{key:o.key,type:"update",attributes:o.attributes}),this}}}],_=[{name:e=>`get${e}Attribute`,attacher:function(e,t,i){e.prototype[t]=function(e,r){let n;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new y(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new y(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let d=""+e,s=""+r;if(r=arguments[2],!(n=o(this,d,s,i)))throw new f(`Graph.${t}: could not find an edge for the given path ("${d}" - "${s}").`)}else{if("mixed"!==i)throw new y(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(n=this._edges.get(e)))throw new f(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return n.attributes[r]}}},{name:e=>`get${e}Attributes`,attacher:function(e,t,i){e.prototype[t]=function(e){let r;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new y(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>1){if(this.multi)throw new y(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let n=""+e,d=""+arguments[1];if(!(r=o(this,n,d,i)))throw new f(`Graph.${t}: could not find an edge for the given path ("${n}" - "${d}").`)}else{if("mixed"!==i)throw new y(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(r=this._edges.get(e)))throw new f(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return r.attributes}}},{name:e=>`has${e}Attribute`,attacher:function(e,t,i){e.prototype[t]=function(e,r){let n;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new y(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new y(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let d=""+e,s=""+r;if(r=arguments[2],!(n=o(this,d,s,i)))throw new f(`Graph.${t}: could not find an edge for the given path ("${d}" - "${s}").`)}else{if("mixed"!==i)throw new y(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(n=this._edges.get(e)))throw new f(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return n.attributes.hasOwnProperty(r)}}},{name:e=>`set${e}Attribute`,attacher:function(e,t,i){e.prototype[t]=function(e,r,n){let d;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new y(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new y(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let s=""+e,a=""+r;if(r=arguments[2],n=arguments[3],!(d=o(this,s,a,i)))throw new f(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if("mixed"!==i)throw new y(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(d=this._edges.get(e)))throw new f(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return d.attributes[r]=n,this.emit("edgeAttributesUpdated",{key:d.key,type:"set",attributes:d.attributes,name:r}),this}}},{name:e=>`update${e}Attribute`,attacher:function(e,t,i){e.prototype[t]=function(e,r,n){let d;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new y(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new y(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let s=""+e,a=""+r;if(r=arguments[2],n=arguments[3],!(d=o(this,s,a,i)))throw new f(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if("mixed"!==i)throw new y(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(d=this._edges.get(e)))throw new f(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if("function"!=typeof n)throw new g(`Graph.${t}: updater should be a function.`);return d.attributes[r]=n(d.attributes[r]),this.emit("edgeAttributesUpdated",{key:d.key,type:"set",attributes:d.attributes,name:r}),this}}},{name:e=>`remove${e}Attribute`,attacher:function(e,t,i){e.prototype[t]=function(e,r){let n;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new y(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new y(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let d=""+e,s=""+r;if(r=arguments[2],!(n=o(this,d,s,i)))throw new f(`Graph.${t}: could not find an edge for the given path ("${d}" - "${s}").`)}else{if("mixed"!==i)throw new y(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(n=this._edges.get(e)))throw new f(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return delete n.attributes[r],this.emit("edgeAttributesUpdated",{key:n.key,type:"remove",attributes:n.attributes,name:r}),this}}},{name:e=>`replace${e}Attributes`,attacher:function(e,t,i){e.prototype[t]=function(e,r){let n;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new y(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new y(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let d=""+e,s=""+r;if(r=arguments[2],!(n=o(this,d,s,i)))throw new f(`Graph.${t}: could not find an edge for the given path ("${d}" - "${s}").`)}else{if("mixed"!==i)throw new y(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(n=this._edges.get(e)))throw new f(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if(!d(r))throw new g(`Graph.${t}: provided attributes are not a plain object.`);return n.attributes=r,this.emit("edgeAttributesUpdated",{key:n.key,type:"replace",attributes:n.attributes}),this}}},{name:e=>`merge${e}Attributes`,attacher:function(e,t,i){e.prototype[t]=function(e,r){let s;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new y(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new y(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let n=""+e,d=""+r;if(r=arguments[2],!(s=o(this,n,d,i)))throw new f(`Graph.${t}: could not find an edge for the given path ("${n}" - "${d}").`)}else{if("mixed"!==i)throw new y(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(s=this._edges.get(e)))throw new f(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if(!d(r))throw new g(`Graph.${t}: provided attributes are not a plain object.`);return n(s.attributes,r),this.emit("edgeAttributesUpdated",{key:s.key,type:"merge",attributes:s.attributes,data:r}),this}}},{name:e=>`update${e}Attributes`,attacher:function(e,t,i){e.prototype[t]=function(e,r){let n;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new y(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new y(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let d=""+e,s=""+r;if(r=arguments[2],!(n=o(this,d,s,i)))throw new f(`Graph.${t}: could not find an edge for the given path ("${d}" - "${s}").`)}else{if("mixed"!==i)throw new y(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(n=this._edges.get(e)))throw new f(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if("function"!=typeof r)throw new g(`Graph.${t}: provided updater is not a function.`);return n.attributes=r(n.attributes),this.emit("edgeAttributesUpdated",{key:n.key,type:"update",attributes:n.attributes}),this}}}],v=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function x(e,t,i,r){let n=!1;for(let o in t){if(o===r)continue;let d=t[o];if(n=i(d.key,d.attributes,d.source.key,d.target.key,d.source.attributes,d.target.attributes,d.undirected),e&&n)return d.key}}function E(e,t,i,r){let n,o,d,s=!1;for(let a in t)if(a!==r){n=t[a];do{if(o=n.source,d=n.target,s=i(n.key,n.attributes,o.key,d.key,o.attributes,d.attributes,n.undirected),e&&s)return n.key;n=n.next}while(void 0!==n)}}function A(e,t){let i,r=Object.keys(e),n=r.length,o=0;return{[Symbol.iterator](){return this},next(){do if(i)i=i.next;else{if(o>=n)return{done:!0};let d=r[o++];if(d===t){i=void 0;continue}i=e[d]}while(!i);return{done:!1,value:{edge:i.key,attributes:i.attributes,source:i.source.key,target:i.target.key,sourceAttributes:i.source.attributes,targetAttributes:i.target.attributes,undirected:i.undirected}}}}}function D(e,t,i,r){let n=t[i];if(!n)return;let o=n.source,d=n.target;if(r(n.key,n.attributes,o.key,d.key,o.attributes,d.attributes,n.undirected)&&e)return n.key}function S(e,t,i,r){let n=t[i];if(!n)return;let o=!1;do{if(o=r(n.key,n.attributes,n.source.key,n.target.key,n.source.attributes,n.target.attributes,n.undirected),e&&o)return n.key;n=n.next}while(void 0!==n)}function U(e,t){let i=e[t];if(void 0!==i.next)return{[Symbol.iterator](){return this},next(){if(!i)return{done:!0};let e={edge:i.key,attributes:i.attributes,source:i.source.key,target:i.target.key,sourceAttributes:i.source.attributes,targetAttributes:i.target.attributes,undirected:i.undirected};return i=i.next,{done:!1,value:e}}};let r=!1;return{[Symbol.iterator](){return this},next:()=>!0===r?{done:!0}:(r=!0,{done:!1,value:{edge:i.key,attributes:i.attributes,source:i.source.key,target:i.target.key,sourceAttributes:i.source.attributes,targetAttributes:i.target.attributes,undirected:i.undirected}})}}function L(e,t,i,r){let n,o;if(0===t.size)return;let d="mixed"!==i&&i!==t.type,s="undirected"===i,a=!1,h=t._edges.values();for(;!0!==(n=h.next()).done;){if(o=n.value,d&&o.undirected!==s)continue;let{key:t,attributes:i,source:h,target:u}=o;if(a=r(t,i,h.key,u.key,h.attributes,u.attributes,o.undirected),e&&a)return t}}function N(e,t,i,r,n,o){let d,s=t?E:x;if("undirected"!==i&&("out"!==r&&(d=s(e,n.in,o),e&&d)||"in"!==r&&(d=s(e,n.out,o,r?void 0:n.key),e&&d)))return d;if("directed"!==i&&(d=s(e,n.undirected,o),e&&d))return d}function C(e,t,i,r,n,o,d){let s,a=i?S:D;if("undirected"!==t&&(void 0!==n.in&&"out"!==r&&(s=a(e,n.in,o,d),e&&s)||void 0!==n.out&&"in"!==r&&(r||n.key!==o)&&(s=a(e,n.out,o,d),e&&s)))return s;if("directed"!==t&&void 0!==n.undirected&&(s=a(e,n.undirected,o,d),e&&s))return s}let j=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function z(){this.A=null,this.B=null}function W(e,t,i,r,n){for(let o in r){let d=r[o],s=d.source,a=d.target,h=s===i?a:s;if(t&&t.has(h.key))continue;let u=n(h.key,h.attributes);if(e&&u)return h.key}}function M(e,t,i,r,n){let o;if("mixed"!==t){if("undirected"===t)return W(e,null,r,r.undirected,n);if("string"==typeof i)return W(e,null,r,r[i],n)}let d=new z;if("undirected"!==t){if("out"!==i){if(o=W(e,null,r,r.in,n),e&&o)return o;d.wrap(r.in)}if("in"!==i){if(o=W(e,d,r,r.out,n),e&&o)return o;d.wrap(r.out)}}if("directed"!==t&&(o=W(e,d,r,r.undirected,n),e&&o))return o}function O(e,t,i){let r=Object.keys(i),n=r.length,o=0;return{[Symbol.iterator](){return this},next(){let d=null;do{if(o>=n)return e&&e.wrap(i),{done:!0};let s=i[r[o++]],a=s.source,h=s.target;if(d=a===t?h:a,e&&e.has(d.key)){d=null;continue}}while(null===d);return{done:!1,value:{neighbor:d.key,attributes:d.attributes}}}}}function K(e,t,i,r,n){let o,d,s,a,h,u,c,p=r._nodes.values(),l=r.type;for(;!0!==(o=p.next()).done;){let r=!1;if(d=o.value,"undirected"!==l)for(s in a=d.out){h=a[s];do{if(u=h.target,r=!0,c=n(d.key,u.key,d.attributes,u.attributes,h.key,h.attributes,h.undirected),e&&c)return h;h=h.next}while(h)}if("directed"!==l){for(s in a=d.undirected)if(!t||!(d.key>s)){h=a[s];do{if((u=h.target).key!==s&&(u=h.source),r=!0,c=n(d.key,u.key,d.attributes,u.attributes,h.key,h.attributes,h.undirected),e&&c)return h;h=h.next}while(h)}}if(i&&!r&&(c=n(d.key,null,d.attributes,null,null,null,null),e&&c))return null}}z.prototype.wrap=function(e){null===this.A?this.A=e:null===this.B&&(this.B=e)},z.prototype.has=function(e){return null!==this.A&&e in this.A||null!==this.B&&e in this.B};let I=function(){let e=255&Math.floor(256*Math.random());return()=>e++}(),P=new Set(["directed","undirected","mixed"]),T=new Set(["domain","_events","_eventsCount","_maxListeners"]),Y={allowSelfLoops:!0,multi:!1,type:"mixed"};function B(e,t,i){let r=new e.NodeDataClass(t,i);return e._nodes.set(t,r),e.emit("nodeAdded",{key:t,attributes:i}),r}function F(e,t,i,r,n,o,s,a){if(!r&&"undirected"===e.type)throw new y(`Graph.${t}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);if(r&&"directed"===e.type)throw new y(`Graph.${t}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);if(a&&!d(a))throw new g(`Graph.${t}: invalid attributes. Expecting an object but got "${a}"`);if(o=""+o,s=""+s,a=a||{},!e.allowSelfLoops&&o===s)throw new y(`Graph.${t}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let h=e._nodes.get(o),u=e._nodes.get(s);if(!h)throw new f(`Graph.${t}: source node "${o}" not found.`);if(!u)throw new f(`Graph.${t}: target node "${s}" not found.`);let c={key:null,undirected:r,source:o,target:s,attributes:a};if(i)n=e._edgeKeyGenerator();else if(n=""+n,e._edges.has(n))throw new y(`Graph.${t}: the "${n}" edge already exists in the graph.`);if(!e.multi&&(r?void 0!==h.undirected[s]:void 0!==h.out[s]))throw new y(`Graph.${t}: an edge linking "${o}" to "${s}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);let p=new $(r,n,h,u,a);e._edges.set(n,p);let l=o===s;return r?(h.undirectedDegree++,u.undirectedDegree++,l&&(h.undirectedLoops++,e._undirectedSelfLoopCount++)):(h.outDegree++,u.inDegree++,l&&(h.directedLoops++,e._directedSelfLoopCount++)),e.multi?p.attachMulti():p.attach(),r?e._undirectedSize++:e._directedSize++,c.key=n,e.emit("edgeAdded",c),n}function J(e,t,i,r,o,s,a,h,u){let c,p,l;if(!r&&"undirected"===e.type)throw new y(`Graph.${t}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`);if(r&&"directed"===e.type)throw new y(`Graph.${t}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`);if(h){if(u){if("function"!=typeof h)throw new g(`Graph.${t}: invalid updater function. Expecting a function but got "${h}"`)}else if(!d(h))throw new g(`Graph.${t}: invalid attributes. Expecting an object but got "${h}"`)}if(s=""+s,a=""+a,u&&(c=h,h=void 0),!e.allowSelfLoops&&s===a)throw new y(`Graph.${t}: source & target are the same ("${s}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let f=e._nodes.get(s),w=e._nodes.get(a);if(!i&&(p=e._edges.get(o))){if((p.source.key!==s||p.target.key!==a)&&(!r||p.source.key!==a||p.target.key!==s))throw new y(`Graph.${t}: inconsistency detected when attempting to merge the "${o}" edge with "${s}" source & "${a}" target vs. ("${p.source.key}", "${p.target.key}").`);l=p}if(l||e.multi||!f||(l=r?f.undirected[a]:f.out[a]),l){let t=[l.key,!1,!1,!1];if(u?!c:!h)return t;if(u){let t=l.attributes;l.attributes=c(t),e.emit("edgeAttributesUpdated",{type:"replace",key:l.key,attributes:l.attributes})}else n(l.attributes,h),e.emit("edgeAttributesUpdated",{type:"merge",key:l.key,attributes:l.attributes,data:h});return t}h=h||{},u&&c&&(h=c(h));let b={key:null,undirected:r,source:s,target:a,attributes:h};if(i)o=e._edgeKeyGenerator();else if(o=""+o,e._edges.has(o))throw new y(`Graph.${t}: the "${o}" edge already exists in the graph.`);let m=!1,k=!1;f||(f=B(e,s,{}),m=!0,s===a&&(w=f,k=!0)),w||(w=B(e,a,{}),k=!0),p=new $(r,o,f,w,h),e._edges.set(o,p);let G=s===a;return r?(f.undirectedDegree++,w.undirectedDegree++,G&&(f.undirectedLoops++,e._undirectedSelfLoopCount++)):(f.outDegree++,w.inDegree++,G&&(f.directedLoops++,e._directedSelfLoopCount++)),e.multi?p.attachMulti():p.attach(),r?e._undirectedSize++:e._directedSize++,b.key=o,e.emit("edgeAdded",b),[o,!0,m,k]}function q(e,t){e._edges.delete(t.key);let{source:i,target:r,attributes:n}=t,o=t.undirected,d=i===r;o?(i.undirectedDegree--,r.undirectedDegree--,d&&(i.undirectedLoops--,e._undirectedSelfLoopCount--)):(i.outDegree--,r.inDegree--,d&&(i.directedLoops--,e._directedSelfLoopCount--)),e.multi?t.detachMulti():t.detach(),o?e._undirectedSize--:e._directedSize--,e.emit("edgeDropped",{key:t.key,attributes:n,source:i.key,target:r.key,undirected:o})}class H extends r.EventEmitter{constructor(e){if(super(),"boolean"!=typeof(e=n({},Y,e)).multi)throw new g(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${e.multi}".`);if(!P.has(e.type))throw new g(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${e.type}".`);if("boolean"!=typeof e.allowSelfLoops)throw new g(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${e.allowSelfLoops}".`);a(this,"NodeDataClass","mixed"===e.type?w:"directed"===e.type?b:m);let t="geid_"+I()+"_",i=0;a(this,"_attributes",{}),a(this,"_nodes",new Map),a(this,"_edges",new Map),a(this,"_directedSize",0),a(this,"_undirectedSize",0),a(this,"_directedSelfLoopCount",0),a(this,"_undirectedSelfLoopCount",0),a(this,"_edgeKeyGenerator",()=>{let e;do e=t+i++;while(this._edges.has(e));return e}),a(this,"_options",e),T.forEach(e=>a(this,e,this[e])),h(this,"order",()=>this._nodes.size),h(this,"size",()=>this._edges.size),h(this,"directedSize",()=>this._directedSize),h(this,"undirectedSize",()=>this._undirectedSize),h(this,"selfLoopCount",()=>this._directedSelfLoopCount+this._undirectedSelfLoopCount),h(this,"directedSelfLoopCount",()=>this._directedSelfLoopCount),h(this,"undirectedSelfLoopCount",()=>this._undirectedSelfLoopCount),h(this,"multi",this._options.multi),h(this,"type",this._options.type),h(this,"allowSelfLoops",this._options.allowSelfLoops),h(this,"implementation",()=>"graphology")}_resetInstanceCounters(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0}hasNode(e){return this._nodes.has(""+e)}hasDirectedEdge(e,t){if("undirected"===this.type)return!1;if(1==arguments.length){let t=""+e,i=this._edges.get(t);return!!i&&!i.undirected}if(2==arguments.length){e=""+e,t=""+t;let i=this._nodes.get(e);return!!i&&i.out.hasOwnProperty(t)}throw new g(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasUndirectedEdge(e,t){if("directed"===this.type)return!1;if(1==arguments.length){let t=""+e,i=this._edges.get(t);return!!i&&i.undirected}if(2==arguments.length){e=""+e,t=""+t;let i=this._nodes.get(e);return!!i&&i.undirected.hasOwnProperty(t)}throw new g(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasEdge(e,t){if(1==arguments.length){let t=""+e;return this._edges.has(t)}if(2==arguments.length){e=""+e,t=""+t;let i=this._nodes.get(e);return!!i&&(void 0!==i.out&&i.out.hasOwnProperty(t)||void 0!==i.undirected&&i.undirected.hasOwnProperty(t))}throw new g(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}directedEdge(e,t){if("undirected"===this.type)return;if(e=""+e,t=""+t,this.multi)throw new y("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");let i=this._nodes.get(e);if(!i)throw new f(`Graph.directedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new f(`Graph.directedEdge: could not find the "${t}" target node in the graph.`);let r=i.out&&i.out[t]||void 0;if(r)return r.key}undirectedEdge(e,t){if("directed"===this.type)return;if(e=""+e,t=""+t,this.multi)throw new y("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");let i=this._nodes.get(e);if(!i)throw new f(`Graph.undirectedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new f(`Graph.undirectedEdge: could not find the "${t}" target node in the graph.`);let r=i.undirected&&i.undirected[t]||void 0;if(r)return r.key}edge(e,t){if(this.multi)throw new y("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");e=""+e,t=""+t;let i=this._nodes.get(e);if(!i)throw new f(`Graph.edge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new f(`Graph.edge: could not find the "${t}" target node in the graph.`);let r=i.out&&i.out[t]||i.undirected&&i.undirected[t]||void 0;if(r)return r.key}areDirectedNeighbors(e,t){e=""+e,t=""+t;let i=this._nodes.get(e);if(!i)throw new f(`Graph.areDirectedNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&(t in i.in||t in i.out)}areOutNeighbors(e,t){e=""+e,t=""+t;let i=this._nodes.get(e);if(!i)throw new f(`Graph.areOutNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in i.out}areInNeighbors(e,t){e=""+e,t=""+t;let i=this._nodes.get(e);if(!i)throw new f(`Graph.areInNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in i.in}areUndirectedNeighbors(e,t){e=""+e,t=""+t;let i=this._nodes.get(e);if(!i)throw new f(`Graph.areUndirectedNeighbors: could not find the "${e}" node in the graph.`);return"directed"!==this.type&&t in i.undirected}areNeighbors(e,t){e=""+e,t=""+t;let i=this._nodes.get(e);if(!i)throw new f(`Graph.areNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&(t in i.in||t in i.out)||"directed"!==this.type&&t in i.undirected}areInboundNeighbors(e,t){e=""+e,t=""+t;let i=this._nodes.get(e);if(!i)throw new f(`Graph.areInboundNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in i.in||"directed"!==this.type&&t in i.undirected}areOutboundNeighbors(e,t){e=""+e,t=""+t;let i=this._nodes.get(e);if(!i)throw new f(`Graph.areOutboundNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in i.out||"directed"!==this.type&&t in i.undirected}inDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new f(`Graph.inDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree}outDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new f(`Graph.outDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.outDegree}directedDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new f(`Graph.directedDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree+t.outDegree}undirectedDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new f(`Graph.undirectedDegree: could not find the "${e}" node in the graph.`);return"directed"===this.type?0:t.undirectedDegree}inboundDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new f(`Graph.inboundDegree: could not find the "${e}" node in the graph.`);let i=0;return"directed"!==this.type&&(i+=t.undirectedDegree),"undirected"!==this.type&&(i+=t.inDegree),i}outboundDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new f(`Graph.outboundDegree: could not find the "${e}" node in the graph.`);let i=0;return"directed"!==this.type&&(i+=t.undirectedDegree),"undirected"!==this.type&&(i+=t.outDegree),i}degree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new f(`Graph.degree: could not find the "${e}" node in the graph.`);let i=0;return"directed"!==this.type&&(i+=t.undirectedDegree),"undirected"!==this.type&&(i+=t.inDegree+t.outDegree),i}inDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new f(`Graph.inDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree-t.directedLoops}outDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new f(`Graph.outDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.outDegree-t.directedLoops}directedDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new f(`Graph.directedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree+t.outDegree-2*t.directedLoops}undirectedDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new f(`Graph.undirectedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"directed"===this.type?0:t.undirectedDegree-2*t.undirectedLoops}inboundDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new f(`Graph.inboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let i=0,r=0;return"directed"!==this.type&&(i+=t.undirectedDegree,r+=2*t.undirectedLoops),"undirected"!==this.type&&(i+=t.inDegree,r+=t.directedLoops),i-r}outboundDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new f(`Graph.outboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let i=0,r=0;return"directed"!==this.type&&(i+=t.undirectedDegree,r+=2*t.undirectedLoops),"undirected"!==this.type&&(i+=t.outDegree,r+=t.directedLoops),i-r}degreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new f(`Graph.degreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let i=0,r=0;return"directed"!==this.type&&(i+=t.undirectedDegree,r+=2*t.undirectedLoops),"undirected"!==this.type&&(i+=t.inDegree+t.outDegree,r+=2*t.directedLoops),i-r}source(e){e=""+e;let t=this._edges.get(e);if(!t)throw new f(`Graph.source: could not find the "${e}" edge in the graph.`);return t.source.key}target(e){e=""+e;let t=this._edges.get(e);if(!t)throw new f(`Graph.target: could not find the "${e}" edge in the graph.`);return t.target.key}extremities(e){e=""+e;let t=this._edges.get(e);if(!t)throw new f(`Graph.extremities: could not find the "${e}" edge in the graph.`);return[t.source.key,t.target.key]}opposite(e,t){e=""+e,t=""+t;let i=this._edges.get(t);if(!i)throw new f(`Graph.opposite: could not find the "${t}" edge in the graph.`);let r=i.source.key,n=i.target.key;if(e===r)return n;if(e===n)return r;throw new f(`Graph.opposite: the "${e}" node is not attached to the "${t}" edge (${r}, ${n}).`)}hasExtremity(e,t){e=""+e,t=""+t;let i=this._edges.get(e);if(!i)throw new f(`Graph.hasExtremity: could not find the "${e}" edge in the graph.`);return i.source.key===t||i.target.key===t}isUndirected(e){e=""+e;let t=this._edges.get(e);if(!t)throw new f(`Graph.isUndirected: could not find the "${e}" edge in the graph.`);return t.undirected}isDirected(e){e=""+e;let t=this._edges.get(e);if(!t)throw new f(`Graph.isDirected: could not find the "${e}" edge in the graph.`);return!t.undirected}isSelfLoop(e){e=""+e;let t=this._edges.get(e);if(!t)throw new f(`Graph.isSelfLoop: could not find the "${e}" edge in the graph.`);return t.source===t.target}addNode(e,t){return function(e,t,i){if(i&&!d(i))throw new g(`Graph.addNode: invalid attributes. Expecting an object but got "${i}"`);if(t=""+t,i=i||{},e._nodes.has(t))throw new y(`Graph.addNode: the "${t}" node already exist in the graph.`);let r=new e.NodeDataClass(t,i);return e._nodes.set(t,r),e.emit("nodeAdded",{key:t,attributes:i}),r}(this,e,t).key}mergeNode(e,t){if(t&&!d(t))throw new g(`Graph.mergeNode: invalid attributes. Expecting an object but got "${t}"`);e=""+e,t=t||{};let i=this._nodes.get(e);return i?(t&&(n(i.attributes,t),this.emit("nodeAttributesUpdated",{type:"merge",key:e,attributes:i.attributes,data:t})),[e,!1]):(i=new this.NodeDataClass(e,t),this._nodes.set(e,i),this.emit("nodeAdded",{key:e,attributes:t}),[e,!0])}updateNode(e,t){if(t&&"function"!=typeof t)throw new g(`Graph.updateNode: invalid updater function. Expecting a function but got "${t}"`);e=""+e;let i=this._nodes.get(e);if(i){if(t){let r=i.attributes;i.attributes=t(r),this.emit("nodeAttributesUpdated",{type:"replace",key:e,attributes:i.attributes})}return[e,!1]}let r=t?t({}):{};return i=new this.NodeDataClass(e,r),this._nodes.set(e,i),this.emit("nodeAdded",{key:e,attributes:r}),[e,!0]}dropNode(e){let t;e=""+e;let i=this._nodes.get(e);if(!i)throw new f(`Graph.dropNode: could not find the "${e}" node in the graph.`);if("undirected"!==this.type){for(let e in i.out){t=i.out[e];do q(this,t),t=t.next;while(t)}for(let e in i.in){t=i.in[e];do q(this,t),t=t.next;while(t)}}if("directed"!==this.type)for(let e in i.undirected){t=i.undirected[e];do q(this,t),t=t.next;while(t)}this._nodes.delete(e),this.emit("nodeDropped",{key:e,attributes:i.attributes})}dropEdge(e){let t;if(arguments.length>1){let e=""+arguments[0],i=""+arguments[1];if(!(t=o(this,e,i,this.type)))throw new f(`Graph.dropEdge: could not find the "${e}" -> "${i}" edge in the graph.`)}else if(e=""+e,!(t=this._edges.get(e)))throw new f(`Graph.dropEdge: could not find the "${e}" edge in the graph.`);return q(this,t),this}dropDirectedEdge(e,t){if(arguments.length<2)throw new y("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new y("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");let i=o(this,e=""+e,t=""+t,"directed");if(!i)throw new f(`Graph.dropDirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return q(this,i),this}dropUndirectedEdge(e,t){if(arguments.length<2)throw new y("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new y("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");let i=o(this,e,t,"undirected");if(!i)throw new f(`Graph.dropUndirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return q(this,i),this}clear(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")}clearEdges(){let e,t=this._nodes.values();for(;!0!==(e=t.next()).done;)e.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")}getAttribute(e){return this._attributes[e]}getAttributes(){return this._attributes}hasAttribute(e){return this._attributes.hasOwnProperty(e)}setAttribute(e,t){return this._attributes[e]=t,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}updateAttribute(e,t){if("function"!=typeof t)throw new g("Graph.updateAttribute: updater should be a function.");let i=this._attributes[e];return this._attributes[e]=t(i),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}removeAttribute(e){return delete this._attributes[e],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:e}),this}replaceAttributes(e){if(!d(e))throw new g("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=e,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this}mergeAttributes(e){if(!d(e))throw new g("Graph.mergeAttributes: provided attributes are not a plain object.");return n(this._attributes,e),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:e}),this}updateAttributes(e){if("function"!=typeof e)throw new g("Graph.updateAttributes: provided updater is not a function.");return this._attributes=e(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this}updateEachNodeAttributes(e,t){let i,r;if("function"!=typeof e)throw new g("Graph.updateEachNodeAttributes: expecting an updater function.");if(t&&!u(t))throw new g("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");let n=this._nodes.values();for(;!0!==(i=n.next()).done;)(r=i.value).attributes=e(r.key,r.attributes);this.emit("eachNodeAttributesUpdated",{hints:t||null})}updateEachEdgeAttributes(e,t){let i,r,n,o;if("function"!=typeof e)throw new g("Graph.updateEachEdgeAttributes: expecting an updater function.");if(t&&!u(t))throw new g("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");let d=this._edges.values();for(;!0!==(i=d.next()).done;)n=(r=i.value).source,o=r.target,r.attributes=e(r.key,r.attributes,n.key,o.key,n.attributes,o.attributes,r.undirected);this.emit("eachEdgeAttributesUpdated",{hints:t||null})}forEachAdjacencyEntry(e){if("function"!=typeof e)throw new g("Graph.forEachAdjacencyEntry: expecting a callback.");K(!1,!1,!1,this,e)}forEachAdjacencyEntryWithOrphans(e){if("function"!=typeof e)throw new g("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");K(!1,!1,!0,this,e)}forEachAssymetricAdjacencyEntry(e){if("function"!=typeof e)throw new g("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");K(!1,!0,!1,this,e)}forEachAssymetricAdjacencyEntryWithOrphans(e){if("function"!=typeof e)throw new g("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");K(!1,!0,!0,this,e)}nodes(){return Array.from(this._nodes.keys())}forEachNode(e){let t,i;if("function"!=typeof e)throw new g("Graph.forEachNode: expecting a callback.");let r=this._nodes.values();for(;!0!==(t=r.next()).done;)e((i=t.value).key,i.attributes)}findNode(e){let t,i;if("function"!=typeof e)throw new g("Graph.findNode: expecting a callback.");let r=this._nodes.values();for(;!0!==(t=r.next()).done;)if(e((i=t.value).key,i.attributes))return i.key}mapNodes(e){let t,i;if("function"!=typeof e)throw new g("Graph.mapNode: expecting a callback.");let r=this._nodes.values(),n=Array(this.order),o=0;for(;!0!==(t=r.next()).done;)i=t.value,n[o++]=e(i.key,i.attributes);return n}someNode(e){let t,i;if("function"!=typeof e)throw new g("Graph.someNode: expecting a callback.");let r=this._nodes.values();for(;!0!==(t=r.next()).done;)if(e((i=t.value).key,i.attributes))return!0;return!1}everyNode(e){let t,i;if("function"!=typeof e)throw new g("Graph.everyNode: expecting a callback.");let r=this._nodes.values();for(;!0!==(t=r.next()).done;)if(!e((i=t.value).key,i.attributes))return!1;return!0}filterNodes(e){let t,i;if("function"!=typeof e)throw new g("Graph.filterNodes: expecting a callback.");let r=this._nodes.values(),n=[];for(;!0!==(t=r.next()).done;)e((i=t.value).key,i.attributes)&&n.push(i.key);return n}reduceNodes(e,t){let i,r;if("function"!=typeof e)throw new g("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new g("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");let n=t,o=this._nodes.values();for(;!0!==(i=o.next()).done;)n=e(n,(r=i.value).key,r.attributes);return n}nodeEntries(){let e=this._nodes.values();return{[Symbol.iterator](){return this},next(){let t=e.next();if(t.done)return t;let i=t.value;return{value:{node:i.key,attributes:i.attributes},done:!1}}}}export(){let e=Array(this._nodes.size),t=0;this._nodes.forEach((i,r)=>{e[t++]=function(e,t){let i={key:e};return s(t.attributes)||(i.attributes=n({},t.attributes)),i}(r,i)});let i=Array(this._edges.size);return t=0,this._edges.forEach((e,r)=>{i[t++]=function(e,t,i){let r={key:t,source:i.source.key,target:i.target.key};return s(i.attributes)||(r.attributes=n({},i.attributes)),"mixed"===e&&i.undirected&&(r.undirected=!0),r}(this.type,r,e)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:e,edges:i}}import(e,t=!1){let i,r,n,o,s;if(e instanceof H)return e.forEachNode((e,i)=>{t?this.mergeNode(e,i):this.addNode(e,i)}),e.forEachEdge((e,i,r,n,o,d,s)=>{t?s?this.mergeUndirectedEdgeWithKey(e,r,n,i):this.mergeDirectedEdgeWithKey(e,r,n,i):s?this.addUndirectedEdgeWithKey(e,r,n,i):this.addDirectedEdgeWithKey(e,r,n,i)}),this;if(!d(e))throw new g("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(e.attributes){if(!d(e.attributes))throw new g("Graph.import: invalid attributes. Expecting a plain object.");t?this.mergeAttributes(e.attributes):this.replaceAttributes(e.attributes)}if(e.nodes){if(!Array.isArray(n=e.nodes))throw new g("Graph.import: invalid nodes. Expecting an array.");for(i=0,r=n.length;i<r;i++){var a=o=n[i];if(!d(a))throw new g('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in a))throw new g("Graph.import: serialized node is missing its key.");if("attributes"in a&&(!d(a.attributes)||null===a.attributes))throw new g("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");let{key:e,attributes:r}=o;t?this.mergeNode(e,r):this.addNode(e,r)}}if(e.edges){let o=!1;if("undirected"===this.type&&(o=!0),!Array.isArray(n=e.edges))throw new g("Graph.import: invalid edges. Expecting an array.");for(i=0,r=n.length;i<r;i++){let e;var h=s=n[i];if(!d(h))throw new g('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in h))throw new g("Graph.import: serialized edge is missing its source.");if(!("target"in h))throw new g("Graph.import: serialized edge is missing its target.");if("attributes"in h&&(!d(h.attributes)||null===h.attributes))throw new g("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in h&&"boolean"!=typeof h.undirected)throw new g("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.");let{source:r,target:a,attributes:u,undirected:c=o}=s;"key"in s?(t?c?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:c?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey).call(this,s.key,r,a,u):(t?c?this.mergeUndirectedEdge:this.mergeDirectedEdge:c?this.addUndirectedEdge:this.addDirectedEdge).call(this,r,a,u)}}return this}nullCopy(e){let t=new H(n({},this._options,e));return t.replaceAttributes(n({},this.getAttributes())),t}emptyCopy(e){let t=this.nullCopy(e);return this._nodes.forEach((e,i)=>{let r=n({},e.attributes);e=new t.NodeDataClass(i,r),t._nodes.set(i,e)}),t}copy(e){let t,i;if("string"==typeof(e=e||{}).type&&e.type!==this.type&&"mixed"!==e.type)throw new y(`Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${e.type}" because this would mean losing information about the current graph.`);if("boolean"==typeof e.multi&&e.multi!==this.multi&&!0!==e.multi)throw new y("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if("boolean"==typeof e.allowSelfLoops&&e.allowSelfLoops!==this.allowSelfLoops&&!0!==e.allowSelfLoops)throw new y("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");let r=this.emptyCopy(e),o=this._edges.values();for(;!0!==(t=o.next()).done;)F(r,"copy",!1,(i=t.value).undirected,i.key,i.source.key,i.target.key,n({},i.attributes));return r}toJSON(){return this.export()}toString(){return"[object Graph]"}inspect(){let e={};this._nodes.forEach((t,i)=>{e[i]=t.attributes});let t={},i={};this._edges.forEach((e,r)=>{let n,o=e.undirected?"--":"->",d="",s=e.source.key,a=e.target.key;e.undirected&&s>a&&(n=s,s=a,a=n);let h=`(${s})${o}(${a})`;r.startsWith("geid_")?this.multi&&(void 0===i[h]?i[h]=0:i[h]++,d+=`${i[h]}. `):d+=`[${r}]: `,t[d+=h]=e.attributes});let r={};for(let e in this)this.hasOwnProperty(e)&&!T.has(e)&&"function"!=typeof this[e]&&"symbol"!=typeof e&&(r[e]=this[e]);return r.attributes=this._attributes,r.nodes=e,r.edges=t,a(r,"constructor",this.constructor),r}}"undefined"!=typeof Symbol&&(H.prototype[Symbol.for("nodejs.util.inspect.custom")]=H.prototype.inspect),[{name:e=>`${e}Edge`,generateKey:!0},{name:e=>`${e}DirectedEdge`,generateKey:!0,type:"directed"},{name:e=>`${e}UndirectedEdge`,generateKey:!0,type:"undirected"},{name:e=>`${e}EdgeWithKey`},{name:e=>`${e}DirectedEdgeWithKey`,type:"directed"},{name:e=>`${e}UndirectedEdgeWithKey`,type:"undirected"}].forEach(e=>{["add","merge","update"].forEach(t=>{let i=e.name(t),r="add"===t?F:J;e.generateKey?H.prototype[i]=function(n,o,d){return r(this,i,!0,"undirected"===(e.type||this.type),null,n,o,d,"update"===t)}:H.prototype[i]=function(n,o,d,s){return r(this,i,!1,"undirected"===(e.type||this.type),n,o,d,s,"update"===t)}})}),function(e){G.forEach(function({name:t,attacher:i}){i(e,t("Node"),0),i(e,t("Source"),1),i(e,t("Target"),2),i(e,t("Opposite"),3)})}(H),function(e){_.forEach(function({name:t,attacher:i}){i(e,t("Edge"),"mixed"),i(e,t("DirectedEdge"),"directed"),i(e,t("UndirectedEdge"),"undirected")})}(H),function(e){v.forEach(t=>{let{name:i,type:r,direction:n}=t;e.prototype[i]=function(e,t){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return[];if(!arguments.length)return function(e,t){let i,r;if(0===e.size)return[];if("mixed"===t||t===e.type)return Array.from(e._edges.keys());let n=Array("undirected"===t?e.undirectedSize:e.directedSize),o="undirected"===t,d=e._edges.values(),s=0;for(;!0!==(i=d.next()).done;)(r=i.value).undirected===o&&(n[s++]=r.key);return n}(this,r);if(1==arguments.length){e=""+e;let t=this._nodes.get(e);if(void 0===t)throw new f(`Graph.${i}: could not find the "${e}" node in the graph.`);return function(e,t,i,r){let n=[];return N(!1,e,t,i,r,function(e){n.push(e)}),n}(this.multi,"mixed"===r?this.type:r,n,t)}if(2==arguments.length){e=""+e,t=""+t;let d=this._nodes.get(e);if(!d)throw new f(`Graph.${i}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new f(`Graph.${i}:  could not find the "${t}" target node in the graph.`);var o=this.multi;let s=[];return C(!1,r,o,n,d,t,function(e){s.push(e)}),s}throw new g(`Graph.${i}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)},function(e,t){let{name:i,type:r,direction:n}=t,o="forEach"+i[0].toUpperCase()+i.slice(1,-1);e.prototype[o]=function(e,t,i){if("mixed"===r||"mixed"===this.type||r===this.type){if(1==arguments.length)return L(!1,this,r,i=e);if(2==arguments.length){e=""+e,i=t;let d=this._nodes.get(e);if(void 0===d)throw new f(`Graph.${o}: could not find the "${e}" node in the graph.`);return N(!1,this.multi,"mixed"===r?this.type:r,n,d,i)}if(3==arguments.length){e=""+e,t=""+t;let d=this._nodes.get(e);if(!d)throw new f(`Graph.${o}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new f(`Graph.${o}:  could not find the "${t}" target node in the graph.`);return C(!1,r,this.multi,n,d,t,i)}throw new g(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)}};let d="map"+i[0].toUpperCase()+i.slice(1);e.prototype[d]=function(){let e,t=Array.prototype.slice.call(arguments),i=t.pop();if(0===t.length){let n=0;"directed"!==r&&(n+=this.undirectedSize),"undirected"!==r&&(n+=this.directedSize),e=Array(n);let o=0;t.push((t,r,n,d,s,a,h)=>{e[o++]=i(t,r,n,d,s,a,h)})}else e=[],t.push((t,r,n,o,d,s,a)=>{e.push(i(t,r,n,o,d,s,a))});return this[o].apply(this,t),e};let s="filter"+i[0].toUpperCase()+i.slice(1);e.prototype[s]=function(){let e=Array.prototype.slice.call(arguments),t=e.pop(),i=[];return e.push((e,r,n,o,d,s,a)=>{t(e,r,n,o,d,s,a)&&i.push(e)}),this[o].apply(this,e),i};let a="reduce"+i[0].toUpperCase()+i.slice(1);e.prototype[a]=function(){let e,t,i=Array.prototype.slice.call(arguments);if(i.length<2||i.length>4)throw new g(`Graph.${a}: invalid number of arguments (expecting 2, 3 or 4 and got ${i.length}).`);if("function"==typeof i[i.length-1]&&"function"!=typeof i[i.length-2])throw new g(`Graph.${a}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);2===i.length?(e=i[0],t=i[1],i=[]):3===i.length?(e=i[1],t=i[2],i=[i[0]]):4===i.length&&(e=i[2],t=i[3],i=[i[0],i[1]]);let r=t;return i.push((t,i,n,o,d,s,a)=>{r=e(r,t,i,n,o,d,s,a)}),this[o].apply(this,i),r}}(e,t);let{name:o,type:d,direction:s}=t,a="find"+o[0].toUpperCase()+o.slice(1,-1);e.prototype[a]=function(e,t,i){if("mixed"!==d&&"mixed"!==this.type&&d!==this.type)return!1;if(1==arguments.length)return L(!0,this,d,i=e);if(2==arguments.length){e=""+e,i=t;let r=this._nodes.get(e);if(void 0===r)throw new f(`Graph.${a}: could not find the "${e}" node in the graph.`);return N(!0,this.multi,"mixed"===d?this.type:d,s,r,i)}if(3==arguments.length){e=""+e,t=""+t;let r=this._nodes.get(e);if(!r)throw new f(`Graph.${a}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new f(`Graph.${a}:  could not find the "${t}" target node in the graph.`);return C(!0,d,this.multi,s,r,t,i)}throw new g(`Graph.${a}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)};let h="some"+o[0].toUpperCase()+o.slice(1,-1);e.prototype[h]=function(){let e=Array.prototype.slice.call(arguments),t=e.pop();return e.push((e,i,r,n,o,d,s)=>t(e,i,r,n,o,d,s)),!!this[a].apply(this,e)};let u="every"+o[0].toUpperCase()+o.slice(1,-1);e.prototype[u]=function(){let e=Array.prototype.slice.call(arguments),t=e.pop();return e.push((e,i,r,n,o,d,s)=>!t(e,i,r,n,o,d,s)),!this[a].apply(this,e)};let{name:l,type:y,direction:w}=t,b=l.slice(0,-1)+"Entries";e.prototype[b]=function(e,t){var i;if("mixed"!==y&&"mixed"!==this.type&&y!==this.type)return p();if(!arguments.length)return function(e,t){if(0===e.size)return p();let i="mixed"!==t&&t!==e.type,r="undirected"===t,n=e._edges.values();return{[Symbol.iterator](){return this},next(){let e,t;for(;;){if((e=n.next()).done)return e;if(t=e.value,!i||t.undirected===r)break}return{value:{edge:t.key,attributes:t.attributes,source:t.source.key,target:t.target.key,sourceAttributes:t.source.attributes,targetAttributes:t.target.attributes,undirected:t.undirected},done:!1}}}}(this,y);if(1==arguments.length){let t;e=""+e;let i=this._nodes.get(e);if(!i)throw new f(`Graph.${b}: could not find the "${e}" node in the graph.`);return t=p(),"undirected"!==y&&("out"!==w&&void 0!==i.in&&(t=c(t,A(i.in))),"in"!==w&&void 0!==i.out&&(t=c(t,A(i.out,w?void 0:i.key)))),"directed"!==y&&void 0!==i.undirected&&(t=c(t,A(i.undirected))),t}if(2==arguments.length){let r;e=""+e,t=""+t;let n=this._nodes.get(e);if(!n)throw new f(`Graph.${b}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new f(`Graph.${b}:  could not find the "${t}" target node in the graph.`);return i=t,r=p(),"undirected"!==y&&(void 0!==n.in&&"out"!==w&&i in n.in&&(r=c(r,U(n.in,i))),void 0!==n.out&&"in"!==w&&i in n.out&&(w||n.key!==i)&&(r=c(r,U(n.out,i)))),"directed"!==y&&void 0!==n.undirected&&i in n.undirected&&(r=c(r,U(n.undirected,i))),r}throw new g(`Graph.${b}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}})}(H),function(e){j.forEach(t=>{let{name:i,type:r,direction:n}=t;e.prototype[i]=function(e){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return[];e=""+e;let t=this._nodes.get(e);if(void 0===t)throw new f(`Graph.${i}: could not find the "${e}" node in the graph.`);var o="mixed"===r?this.type:r;if("mixed"!==o){if("undirected"===o)return Object.keys(t.undirected);if("string"==typeof n)return Object.keys(t[n])}let d=[];return M(!1,o,n,t,function(e){d.push(e)}),d},function(e,t){let{name:i,type:r,direction:n}=t,o="forEach"+i[0].toUpperCase()+i.slice(1,-1);e.prototype[o]=function(e,t){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return;e=""+e;let i=this._nodes.get(e);if(void 0===i)throw new f(`Graph.${o}: could not find the "${e}" node in the graph.`);M(!1,"mixed"===r?this.type:r,n,i,t)};let d="map"+i[0].toUpperCase()+i.slice(1);e.prototype[d]=function(e,t){let i=[];return this[o](e,(e,r)=>{i.push(t(e,r))}),i};let s="filter"+i[0].toUpperCase()+i.slice(1);e.prototype[s]=function(e,t){let i=[];return this[o](e,(e,r)=>{t(e,r)&&i.push(e)}),i};let a="reduce"+i[0].toUpperCase()+i.slice(1);e.prototype[a]=function(e,t,i){if(arguments.length<3)throw new g(`Graph.${a}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let r=i;return this[o](e,(e,i)=>{r=t(r,e,i)}),r}}(e,t);let{name:o,type:d,direction:s}=t,a=o[0].toUpperCase()+o.slice(1,-1),h="find"+a;e.prototype[h]=function(e,t){if("mixed"!==d&&"mixed"!==this.type&&d!==this.type)return;e=""+e;let i=this._nodes.get(e);if(void 0===i)throw new f(`Graph.${h}: could not find the "${e}" node in the graph.`);return M(!0,"mixed"===d?this.type:d,s,i,t)},e.prototype["some"+a]=function(e,t){return!!this[h](e,t)},e.prototype["every"+a]=function(e,t){return!this[h](e,(e,i)=>!t(e,i))};let{name:u,type:l,direction:y}=t,w=u.slice(0,-1)+"Entries";e.prototype[w]=function(e){if("mixed"!==l&&"mixed"!==this.type&&l!==this.type)return p();e=""+e;let t=this._nodes.get(e);if(void 0===t)throw new f(`Graph.${w}: could not find the "${e}" node in the graph.`);var i="mixed"===l?this.type:l;if("mixed"!==i){if("undirected"===i)return O(null,t,t.undirected);if("string"==typeof y)return O(null,t,t[y])}let r=p(),n=new z;return"undirected"!==i&&("out"!==y&&(r=c(r,O(n,t,t.in))),"in"!==y&&(r=c(r,O(n,t,t.out)))),"directed"!==i&&(r=c(r,O(n,t,t.undirected))),r}})}(H);class Q extends H{constructor(e){let t=n({type:"directed"},e);if("multi"in t&&!1!==t.multi)throw new g("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("directed"!==t.type)throw new g('DirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class R extends H{constructor(e){let t=n({type:"undirected"},e);if("multi"in t&&!1!==t.multi)throw new g("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("undirected"!==t.type)throw new g('UndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class V extends H{constructor(e){let t=n({multi:!0},e);if("multi"in t&&!0!==t.multi)throw new g("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");super(t)}}class X extends H{constructor(e){let t=n({type:"directed",multi:!0},e);if("multi"in t&&!0!==t.multi)throw new g("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("directed"!==t.type)throw new g('MultiDirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class Z extends H{constructor(e){let t=n({type:"undirected",multi:!0},e);if("multi"in t&&!0!==t.multi)throw new g("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("undirected"!==t.type)throw new g('MultiUndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}function ee(e){e.from=function(t,i){let r=new e(n({},t.options,i));return r.import(t),r}}ee(H),ee(Q),ee(R),ee(V),ee(X),ee(Z),H.Graph=H,H.DirectedGraph=Q,H.UndirectedGraph=R,H.MultiGraph=V,H.MultiDirectedGraph=X,H.MultiUndirectedGraph=Z,H.InvalidArgumentsGraphError=g,H.NotFoundGraphError=f,H.UsageGraphError=y}}]);